// ‚ÄúMiddleware in Express is essentially a function that sits between the incoming request and the final response.
//  It has access to the req, res, and next objects, and it‚Äôs the foundation for building scalable Express apps 
// because it allows us to layer responsibilities like authentication, logging, validation, and error handling in a clean, modular way.‚Äù

// ‚∏ª

// ‚úÖ 3 Types of Middleware (Show depth)
// 	1.	Application-level middleware ‚Üí Defined using app.use(). Example: Logging every request, body parsing.
// 	2.	Router-level middleware ‚Üí Applied to specific routes via express.Router(). Example: Route-specific authentication.
// 	3.	Error-handling middleware ‚Üí Defined with 4 parameters (err, req, res, next). Example: Centralized error handler.

// ‚∏ª

// ‚úÖ Examples You Can Quote


// 1Ô∏è‚É£ Authentication Middleware (JWT / Sessions)
// 	‚Ä¢	Checks if a request has a valid token before allowing access.
// 	‚Ä¢	Example: For protected routes, I used a middleware that verifies JWT from the Authorization header, decodes it, 
// attaches the user object to req.user, and only then continues.
// 	‚Ä¢	If token is invalid or missing ‚Üí return 401 Unauthorized.
    function authMiddleware(req, res, next) {
  const token = req.headers['authorization']?.split(' ')[1];
  if (!token) return res.status(401).json({ message: 'No token provided' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // attach user payload to request
    next(); // go to next middleware or controller
  } catch (err) {
    return res.status(403).json({ message: 'Invalid token' });
  }
}


// 2Ô∏è‚É£ Logging Middleware
// 	‚Ä¢	Logs details of each incoming request for monitoring and debugging.
// 	‚Ä¢	Example: I implemented a middleware that logs the HTTP method, URL, and timestamp of each request to the console or a log file.
function loggingMiddleware(req, res, next) {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next(); // proceed to the next middleware or route handler
}
// 	‚Ä¢	This helps track API usage and diagnose issues.
// 	‚Ä¢	For more advanced logging, I integrated Winston to log to files with different levels (info, error). 



// 3Ô∏è‚É£ Error-Handling Middleware
// 	‚Ä¢	Catches errors thrown in routes or other middleware and sends a consistent error response
function errorHandlingMiddleware(err, req, res, next) {
  console.error(err.stack); // log the error stack for debugging
  res.status(500).json({ message: 'Something went wrong!' }); // send generic error response
}   
// 	‚Ä¢	Example: I created an error-handling middleware that captures any errors passed via next(err) and returns a JSON response with
//  a 500 status code and a message.
// 	‚Ä¢	This centralizes error handling and avoids repetitive try-catch blocks in each route.
// 	‚Ä¢	For specific error types (like validation errors), I check the error instance and return appropriate status codes (e.g., 400 Bad Request).




// 4Ô∏è‚É£ Rate Limiting Middleware
// 	‚Ä¢	Limits the number of requests a client can make in a given time window to prevent abuse.
// 	‚Ä¢	Example: I used the express-rate-limit package to create a middleware that restricts clients to 100 requests per 15 minutes.
// 	‚Ä¢	If the limit is exceeded, it returns a 429 Too Many Requests response.
const rateLimit = require('express-rate-limit');
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
// 	‚Ä¢	This helps protect against brute-force attacks and reduces server load during traffic spikes.




// 5Ô∏è‚É£ Body Parsing Middleware
// 	‚Ä¢	Parses incoming request bodies and makes the data available on req.body.
// 	‚Ä¢	Example: I used express.json() middleware to automatically parse JSON request bodies.
const express = require('express');
const app = express();
app.use(express.json()); // for parsing application/json
// 	‚Ä¢	This allows route handlers to easily access submitted data without manually parsing it.
// 	‚Ä¢	I also used express.urlencoded() for parsing URL-encoded form data when handling form submissions.



// 6Ô∏è‚É£ CORS Middleware
// 	‚Ä¢	Enables Cross-Origin Resource Sharing to allow or restrict requests from different origins.
// 	‚Ä¢	Example: I used the cors package to set up middleware that allows requests from specific domains.
const cors = require('cors');
app.use(cors({
  origin: 'https://example.com', // allow only this origin
  methods: ['GET', 'POST'], // allow only GET and POST requests
}));
// 	‚Ä¢	This is essential for APIs that are accessed from web applications hosted on different domains.
// 	‚Ä¢	I configured it to allow credentials (cookies, authorization headers) when needed.
// ‚∏ª    


// <------------------------------------------------------------------------->

// ‚úÖ Why Middleware is Powerful (sell your expertise)
// 	‚Ä¢	Reusability: Encapsulates logic once, reuse across routes.
// 	‚Ä¢	Separation of Concerns: Each middleware has a single responsibility.
// 	‚Ä¢	Extensibility: Third-party middleware (Helmet, CORS, morgan, compression) can be plugged in easily.
// 	‚Ä¢	Scalability: Complex flows (auth ‚Üí validation ‚Üí controller ‚Üí error handling) become manageable.

// ‚∏ª

// üìù Final Interview Cheat Sheet Answer

// ‚ÄúMiddleware in Express is a layered function that processes requests before reaching the final route handler. 
// It‚Äôs the backbone of Express apps. I‚Äôve used it for authentication (JWT/session-based), logging (morgan/custom), 
// validation (Joi/express-validator), and error handling (centralized 4-arg middleware). It makes the app modular, reusable, and secure. 
// Without middleware, managing large Express apps would be messy.‚Äù


// different levels of middleware with examples you can quote in interview.

// application level middleware
// router level middleware
// error handling middleware


// different levels of middleware with examples you can quote in interview.

// 1. Application-level middleware example
// Logs every request made to the app
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// 2. Router-level middleware example
// Applies authentication only to routes under /admin
const adminRouter = express.Router();
adminRouter.use(authMiddleware);
adminRouter.get('/dashboard', (req, res) => {
  res.send('Welcome to admin dashboard');
});
app.use('/admin', adminRouter);

// 3. Error-handling middleware example
// Catches errors and sends a unified response
app.use((err, req, res, next) => {
  console.error(err);
  res.status(err.status || 500).json({ error: err.message || 'Internal Server Error' });
});