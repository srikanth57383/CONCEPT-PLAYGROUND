; 🚀 Scaling Node.js Apps (Clustering, PM2, Workers)

; 1. Why Scaling is Needed
; 	•	Node.js runs on a single thread → can handle many requests (event loop + async I/O) but only uses one CPU core.
; 	•	On multi-core machines, your app isn’t fully utilizing hardware.
; 	•	Scaling helps:
; 	•	Handle more concurrent traffic.
; 	•	Improve fault tolerance (if one process crashes, others survive).
; 	•	Distribute workload.

; ⸻

; 2. Clustering
; 	•	Clustering = running multiple instances of your Node.js app to utilize multiple CPU cores.
; 	•	Node’s built-in cluster module spawns worker processes that share the same server port.

; 🔑 Key points:
; 	•	Master process → spawns & manages workers.
; 	•	Workers → handle client requests.
; 	•	Load balancing is handled internally (round-robin in recent Node versions).

; const cluster = require("cluster");
; const http = require("http");
; const os = require("os");

; if (cluster.isMaster) {
;   const numCPUs = os.cpus().length;
;   console.log(`Master ${process.pid} is running`);

;   // Fork workers
;   for (let i = 0; i < numCPUs; i++) {
;     cluster.fork();
;   }

;   cluster.on("exit", (worker) => {
;     console.log(`Worker ${worker.process.pid} died. Restarting...`);
;     cluster.fork();
;   });
; } else {
;   // Worker processes
;   http.createServer((req, res) => {
;     res.writeHead(200);
;     res.end(`Handled by worker ${process.pid}\n`);
;   }).listen(3000);

;   console.log(`Worker ${process.pid} started`);
; }
; ✅ Interview Highlight:
; “Clustering lets Node.js apps scale across all CPU cores. The master process manages workers, and if one crashes, it can restart automatically.”

; ⸻
; 3. PM2 (Process Manager 2)
; 	•	Production-ready process manager for Node.js.
; 	•	Handles:
; 	•	Clustering
; 	•	Auto-restarts on crash
; 	•	Load balancing
; 	•	Log management
; 	•	Monitoring & metrics

; 📌 Example commands:
; # Start in cluster mode using all CPU cores
; pm2 start app.js -i max

; # Start with 4 instances
; pm2 start app.js -i 4

; # Monitor processes
; pm2 monit

; # Restart if app crashes
; pm2 restart app

; # Save process config
; pm2 save

; ✅ Interview Highlight:
; “PM2 simplifies managing Node.js apps in production. It provides clustering, auto-restarts,
;  and monitoring out of the box, making it easy to keep apps running smoothly.”



;  4. Worker Threads (vs Clustering)
; 	•	Introduced in Node.js v10.5+, stable in v12+.
; 	•	Workers allow multithreading in a single process.
; 	•	Useful for CPU-intensive tasks (e.g., image processing, encryption, ML calculations).
; 	•	Unlike clustering, workers share memory via SharedArrayBuffer.

; 📌 Example:const { Worker, isMainThread, parentPort } = require("worker_threads");

; if (isMainThread) {
;   console.log("Main thread");
;   const worker = new Worker(__filename);
;   worker.on("message", msg => console.log("From worker:", msg));
;   worker.postMessage("Hello Worker!");
; } else {
;   parentPort.on("message", msg => {
;     parentPort.postMessage(`Worker received: ${msg}`);
;   });
; }
; ✅ Interview Highlight:
; “Clustering scales across CPU cores for handling multiple requests, but Worker Threads are best when you need to offload CPU-heavy tasks without blocking the event loop.”

; ⸻

; 5. When to Use What
;     •	Clustering/PM2 → Scale web servers to handle more concurrent requests.
;     •	Worker Threads → Offload CPU-intensive tasks within a single app instance.
;     •	Both can be combined: Use PM2 for clustering and Worker Threads for heavy computations in each worker.

; ⸻
; 🔥 Interview Tricky Qs & Answers

; 	•	Node.js is single-threaded, but we scale apps via clustering.
; 	•	Cluster module → creates multiple worker processes using all CPU cores.
; 	•	PM2 → process manager, makes clustering, monitoring, and restarts easy.
; 	•	Worker Threads → multithreading for CPU-heavy work, not request handling.
; 	•	Common real-world combo: PM2 (clustering) + Worker Threads (CPU jobs).

; ⸻


; Q1: How to handle session data in a clustered Node.js app?
; 	• Use a centralized session store (e.g., Redis) to share session data across workers.

; Q2: When to use Worker Threads over Clustering?
; 	• Use Worker Threads for CPU-intensive tasks that need to run in parallel without blocking the event loop.
; 	• Use Clustering to handle more concurrent requests by utilizing multiple CPU cores.

; Q3: Can you use both Clustering and Worker Threads together?
; 	• Yes, you can use PM2 for clustering and Worker Threads for heavy computations in each worker.
