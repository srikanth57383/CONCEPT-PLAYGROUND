// 1. ğŸŸ¢ Buffer in Node.js
// 	â€¢	A Buffer is a raw binary data container in Node.js.
// 	â€¢	Used when dealing with streams (file system, network, etc.) because data doesnâ€™t always come in one chunk.
// 	â€¢	Buffers are fixed-size memory allocations outside the V8 heap (handled by Node.js).

// Example:
// const buf = Buffer.from("Hello");
// console.log(buf);       // <Buffer 48 65 6c 6c 6f>
// console.log(buf.toString()); // "Hello"

// ğŸ‘‰ Interview tip:
// 	â€¢	Buffers let Node handle binary data (like images, files) efficiently.

// 2. ğŸŸ¡ What is Backpressure?
// 	â€¢	Backpressure happens when the receiving side of a stream cannot handle data as fast as the source is sending it.
// 	â€¢	Think of it as: Producer is too fast, consumer is too slow.
// 	â€¢	If not handled, it can lead to:
// 	â€¢	High memory usage.
// 	â€¢	Crashes (too many chunks buffered in memory).

// ğŸ‘‰ Example:
// 	â€¢	Youâ€™re reading a huge file and writing it to a network socket.
// 	â€¢	If the network is slow, data piles up in memory â†’ backpressure.

// â¸»

// 3. ğŸ”´ How Node.js Handles Backpressure (pipe())
// 	â€¢	Streams in Node.js have built-in mechanisms to handle backpressure.
// 	â€¢	The method readableStream.pipe(writableStream) automatically:
// 	1.	Pauses the readable stream when the writable is overwhelmed.
// 	2.	Resumes when the writable is ready again.
// 	3.	Prevents memory overload.


// Example without pipe (bad):
//  const fs = require('fs');
// const readStream = fs.createReadStream('largeFile.txt');
// const writeStream = fs.createWriteStream('output.txt');
//  If writable.write() is slower, memory can fill up.

// Example with pipe (good):
// const fs = require('fs');
// const readStream = fs.createReadStream('largeFile.txt');
// const writeStream = fs.createWriteStream('output.txt');
// âœ… Backpressure handled automatically
// readStream.pipe(writeStream);
// ğŸ‘‰ With .pipe(), Node will:
// 	â€¢	Stop reading if the writable is busy.
// 	â€¢	Resume once writable drains data.

// 5. ğŸ“ Interview-Ready Summary
// 	â€¢	Buffer: Temporary storage for binary data in memory.
// Backpressure: Happens when writable stream is slower than readable, causing memory buildup.
// 	â€¢	pipe(): Safely connects readable â†’ writable stream, automatically managing backpressure.
// 	â€¢	If not using .pipe(), you must manually pause/resume streams based on "drain".

// ğŸ‘‰ Common Interview Question:
// Q: â€œHow does Node.js handle backpressure when streaming data?â€
// A (Pro):
// â€œBackpressure occurs when data is produced faster than it can be consumed. In Node.js, 
// using .pipe() between streams automatically manages backpressure by pausing the readable stream when the writable is full and resuming when it drains.
//  Without .pipe(), we must manually check writable.write() and listen for the drain event. 
// Buffers are used internally to hold chunks temporarily during this process.â€

// â¸»
