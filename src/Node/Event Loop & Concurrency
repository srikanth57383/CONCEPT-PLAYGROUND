; üöÄ How Node.js is Single-Threaded (with Event Loop, I/O, and Workers)

; üß† Core Idea
; 	‚Ä¢	Node.js uses a single main thread (JavaScript thread) to execute application code.
; 	‚Ä¢	This thread runs the Event Loop, which manages asynchronous operations.
; 	‚Ä¢	Heavy I/O operations (like network calls, file reads, DB queries) are delegated to background workers (libuv‚Äôs thread pool), 
;     so they don‚Äôt block the main thread.

; ‚∏ª

; 1. üü¢ Event Loop & Non-Blocking I/O
; 	‚Ä¢	Node.js runs on a single thread for executing JavaScript.
; 	‚Ä¢	When you trigger an async task (e.g., fs.readFile, DB query, API call):
; 	1.	The task is delegated to libuv‚Äôs thread pool or OS.
; 	2.	The main thread (event loop) keeps processing other code.
; 	3.	Once the task is done, its callback is queued in the Event Loop.
; 	4.	The Event Loop picks up queued callbacks and executes them when the call stack is empty.
; ‚∏ª
; 2. üü° Microtasks vs. Macrotasks in Event Loop

; When a callback is queued, it isn‚Äôt executed immediately. The Event Loop has two main queues:
; 	‚Ä¢	Microtasks Queue (High Priority)
; 	‚Ä¢	Examples: process.nextTick(), Promise .then(), queueMicrotask().
; 	‚Ä¢	Always executed immediately after the current operation (before macrotasks).
; 	‚Ä¢	Macrotasks Queue (Normal Priority)
; 	‚Ä¢	Examples: setTimeout, setInterval, setImmediate, I/O callbacks.
; 	‚Ä¢	Executed after microtasks are cleared.

; üëâ Execution order:
; 	1.	Run current JavaScript code (call stack).
; 	2.	Run all microtasks (Promises, nextTick).
; 	3.	Pick and execute the next macrotask.
; 	4.	Repeat

; -------    
; 3. üî¥ Example (Micro vs Macro)
; -----------------------------------------
; console.log("Start");

; setTimeout(() => console.log("Macrotask: setTimeout"), 0);

; Promise.resolve().then(() => console.log("Microtask: Promise"));

; process.nextTick(() => console.log("Microtask: nextTick"));

; console.log("End");
; -----------------------------------------
; // Output:
; // Start
; // End
; // Microtask: nextTick
; // Microtask: Promise
; // Macrotask: setTimeout


; \üëâ Why?
; 	‚Ä¢	JS executes synchronously first (Start, End).
; 	‚Ä¢	Then microtasks (nextTick, Promise).
; 	‚Ä¢	Finally, macrotasks (setTimeout).
; -------    

;  4. üü£ Concurrency vs Parallelism
; 	‚Ä¢	Concurrency: Event Loop + Micro/Macro queues handle many tasks efficiently on one thread.
; 	‚Ä¢	Parallelism: True multi-core execution using Worker Threads or Clustering.





; -------    
;   5. üü° CPU-Intensive Tasks
; 	‚Ä¢	Example: image processing, encryption, big loops.
; 	‚Ä¢	These tasks block the single thread, since they‚Äôre synchronous.
; 	‚Ä¢	Solution:
; 	‚Ä¢	Use Worker Threads (introduced in Node v10.5) to run CPU-bound tasks in parallel.
; 	‚Ä¢	Or move heavy work to microservices in other languages (C++, Go, etc.).

; ‚∏ª

; 6. üî¥ Concurrency in Node.js
; 	‚Ä¢	Even though Node.js has one main thread, it achieves concurrency via:
; 	‚Ä¢	Event Loop ‚Üí manages multiple tasks without blocking.
; 	‚Ä¢	Non-blocking I/O ‚Üí delegates I/O work to OS or libuv workers.
; 	‚Ä¢	Worker Threads / Cluster ‚Üí allows parallelism when required.

; Concurrency ‚â† Parallelism:
; 	‚Ä¢	Concurrency: Node.js switches between multiple tasks efficiently (async, event loop).
; 	‚Ä¢	Parallelism: Multiple tasks run literally at the same time on different CPU cores (via Workers or Clustering).

; ‚∏ª

; 4. üìù Interview-Friendly Analogy

; Think of Node.js as a restaurant with one waiter.
; 	‚Ä¢	The waiter takes an order (request).
; 	‚Ä¢	If the dish requires slow cooking (I/O task), he gives it to the kitchen staff (thread pool).
; 	‚Ä¢	While waiting, the waiter takes more orders.
; 	‚Ä¢	When the dish is ready, the kitchen tells the waiter, who serves it.

; This way, one waiter handles many customers without getting stuck.

; ‚∏ª

; 5. ‚úÖ Key Points to Say in Interview
; 	‚Ä¢	Node.js is single-threaded in terms of executing JavaScript.
; 	‚Ä¢	The Event Loop enables concurrency by delegating I/O tasks to libuv workers.
; 	‚Ä¢	Node.js is best for I/O-intensive tasks (APIs, DB queries, file/network ops).
; 	‚Ä¢	For CPU-intensive tasks, use Worker Threads or Clustering.

; ‚∏ª

; üîë Sample Interview Answer (short & pro):

; ‚ÄúNode.js is single-threaded because it runs JavaScript code on a single thread using the Event Loop. However, it achieves
;  concurrency through non-blocking I/O. I/O tasks are delegated to the libuv thread pool, allowing the main thread to 
;  continue handling other requests. This makes Node.js highly efficient for I/O-bound applications like APIs or real-time apps.
;   For CPU-intensive tasks, Node.js provides Worker Threads and Clustering to leverage multiple cores. 
;   So, Node is single-threaded for JavaScript execution but concurrent in handling multiple operations.‚Äù