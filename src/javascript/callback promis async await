// ; ðŸ”¹ JavaScript â€“ Callbacks vs Promises vs Async/Await (Interview Notes)

// ; 1. Callbacks
// ; 	â€¢	Definition: A callback is a function passed as an argument to another function, executed later once the task is completed.
// ; 	â€¢	Use case: Handling asynchronous tasks like reading files, making API calls, timers.
// ; 	â€¢	Problem: Leads to Callback Hell (nested callbacks â†’ hard to read, maintain, and debug).

// ; Example:
// ; function fetchData(callback) {
// ;   setTimeout(() => {
// ;     callback("Data received");
// ;   }, 1000);
// ; }

// ; fetchData((data) => {
// ;   console.log(data); // Data received
// ; });
// ; Callback Hell
// ; doTask1(() => {
// ;   doTask2(() => {
// ;     doTask3(() => {
// ;       console.log("All tasks done");
// ;     });
// ;   });
// ; });



// ; 2. Promises
// ; 	â€¢	Definition: An object representing eventual completion (resolve) or failure (reject) of an async operation.
// ; 	â€¢	States:
// ; 	â€¢	Pending
// ; 	â€¢	Fulfilled â†’ resolve(value)
// ; 	â€¢	Rejected â†’ reject(reason)
// ; 	â€¢	Advantages over Callbacks: Avoids callback hell, provides chaining (.then(), .catch()).
// ; Example:
// ; let promise = new Promise((resolve, reject) => {
// ;   setTimeout(() => resolve("Success!"), 1000);
// ; });

// ; promise
// ;   .then(result => console.log(result))
// ;   .catch(err => console.error(err));

// ;   Useful Promise methods:
// ; 	â€¢	Promise.all([p1, p2, ...]) â†’ Waits for all to resolve, rejects if any fail.
// ; 	â€¢	Promise.allSettled([p1, p2, ...]) â†’ Waits for all, gives status of each.
// ; 	â€¢	Promise.any([p1, p2, ...]) â†’ Returns first fulfilled promise.
// ; 	â€¢	Promise.race([p1, p2, ...]) â†’ Returns first settled (resolve or reject).

// ; â¸»
// ; 3. Async/Await
// ;     â€¢	Definition: Syntactic sugar over Promises, allows writing async code that looks synchronous.
// ;     â€¢	'async' keyword before a function makes it return a Promise.
// ;     â€¢	'await' keyword pauses execution until the Promise resolves or rejects.
// ;     â€¢	Advantages: Cleaner, more readable code, easier error handling with try/catch.
// ;     â€¢	Rules:
// ; 	     â€¢	async function â†’ always returns a Promise.
// ; 	     â€¢	await pauses execution until the promise resolves.
// ; Example:            

// async function fetchData() {
//   try {
//     let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
//     let data = await response.json();
//     console.log(data);
//   } catch (error) {
//     console.error("Error:", error);
//   }
// }

// fetchData();

// ; IMPORTANCE:
// ; 	â€¢	Callbacks were the first async solution, but led to callback hell.
// ; 	â€¢	Promises solved readability issues, introduced chaining & error handling.
// ; 	â€¢	Async/Await is syntactic sugar over promises, gives clean, synchronous-like code.
// ; 	â€¢	All 3 do the same job, just different syntax & readability.