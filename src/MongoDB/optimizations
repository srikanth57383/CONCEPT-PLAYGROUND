<!-- 1. Indexes

Indexes make queries faster (like a book index).
Without them, MongoDB scans every document (COLLSCAN).
	â€¢	Types of Indexes
	â€¢	Single Field â†’ db.users.createIndex({ age: 1 })
	â€¢	Compound â†’ db.users.createIndex({ age: 1, city: 1 })
	â€¢	Text Index â†’ db.articles.createIndex({ content: "text" })
	â€¢	Unique Index â†’ db.users.createIndex({ email: 1 }, { unique: true })
	â€¢	TTL Index â†’ auto-delete docs â†’ db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })
	â€¢	Best Practices
	â€¢	Always index fields used in query filters, sorts, and joins (lookup).
	â€¢	Avoid over-indexing (slows down writes).
	â€¢	Use covered queries (index includes all queried fields).


2. Aggregation

Aggregation framework processes and transforms data in stages (like SQLâ€™s GROUP BY + HAVING).
	â€¢	Common Stages
	â€¢	$match â†’ filter documents early (uses indexes).
	â€¢	$group â†’ group docs, do counts, sums, averages.
	â€¢	$project â†’ reshape fields.
	â€¢	$sort â†’ sort docs (use indexes if possible).
	â€¢	$lookup â†’ joins between collections.
	â€¢	$facet â†’ run multiple aggregations in one query.
	â€¢	Best Practices
	â€¢	Push $match and $project as early as possible.
	â€¢	Use $limit before $sort on large collections.
	â€¢	Avoid $lookup on huge collections â†’ denormalize if needed.

    3. Schema Design

MongoDB is schema-less but design matters for performance.
	â€¢	Patterns
	â€¢	Embedding (store related data in same document):
	â€¢	Good for one-to-few, read-heavy workloads.
	â€¢	Example: store comments inside a post.
	â€¢	Referencing (store _id references):
	â€¢	Good for one-to-many, write-heavy workloads.
	â€¢	Example: userId inside orders.
	â€¢	Best Practices
	â€¢	Design based on query patterns, not just data structure.
	â€¢	Keep documents under 16MB limit.
	â€¢	Use pre-aggregated fields for analytics (counters).
	â€¢	Avoid deep nesting (slower queries, harder updates).


ðŸ“ Interview Summary (Cheat Sheet)
	â€¢	Indexes â†’ Speed up queries (COLLSCAN â†’ IXSCAN). Use single, compound, unique, TTL. Avoid too many indexes.
	â€¢	Aggregation â†’ MongoDBâ€™s query pipeline. Push $match early, use $project wisely, minimize $lookup.
	â€¢	Schema Design â†’ Optimize for access patterns. Use embedding for small, related data. Use referencing for large/many relations.

ðŸ‘‰ Example Interview Answer:
â€œIn MongoDB, optimizations mainly come from three areas: indexes to speed up queries, aggregation pipelines for efficient data processing, and schema design based on query patterns. Iâ€™d ensure frequently queried fields are indexed, push filtering early in aggregation, and choose embedding vs referencing depending on read/write patterns. This reduces query time and improves scalability.â€

â¸» -->
